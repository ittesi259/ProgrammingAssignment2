head(rownames(a), 3)
a
a <- available.packages()
head(rownames(a) ,3)
a
available.packages()
install.packages("slidify")
chooseCRANmirror()
install.packages("slidify")
install.packages("ggplot2")
install.packages("devtools")
install.packages("shiny")
utils:::menuInstallPkgs()
q()
install.packages("slidify")
source("http://bioconductor.org/bioLite.r")
source("http://bioconductor.org/biocLite.r")
source("http://bioconductor.org/biocLite.R")
biocLite()
install.packages("shiny")
library(ggplot2)
library(ggplot2)
search()
install.packages(debtools)
install.packages("devtools")
findFunction("devtools"")
find.package("devtools")
find.package("devtools")
find.package("ggplot2")
library(devtools)
find_rtools()
install.packages("KernSmooth")
library(KernSmooth)
install.packages("swirl")
packageVersion("swirl")
library(swirl)
ls
ls(list=ls())
rm(list=ls())
install_from_swirl("R Programming")
swirl()
5+7
x <- 5+7
x
y <- x - 3
y
z <- c(1.1, 9, 3.14)
?c
z
c(z, 555, z)
z * 2 +100
my_sqrt <- (sqrt(z - 1))
my_sqrt <- sqrt(z - 1)
my_sqrt
my_div <- z / my_sqrt
my_div
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10, 100)
z * 2 +1000
my_div
swirl()
cube <- function(x ,n) {
x^3
}
cube(3)
x <- 1:10
if(x>5) {
x <-0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <=10
z <- 10
f(3)
library(datasets)
data(iris)
?iris
iris
iris
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], `, mean)
apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 2, mean)
apply(iris[ , 1:4], 2, mean)
apply(iris[ , 1:4], 2, mean)
str(iris)
virginica <-subset(iris,Species=="virginica")
SepalLength<-data.frame(virginica$Sepal.Length)
SepalLength
mean(SepalLength)
apply(SepalLength, mean)
?apply
apply(SepalLength,2, mean)
library(datasets)
data("mtcars")
?mtcars
mtcars
sapply(mtcars, cyl, mean)
apply(mtcars, 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
with(mtcars, tapply(mpg, cyl, mean))
lapply(mtcars, mean)
apply(mtcars, 2, mean)
split(mtcars, mtcars$cyl)
tapply(mtcars$cyl, mtcars$mpg, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
lapply(mtcars, mean)
mean(mtcars$mpg, mtcars$cyl)
split(mtcars, mtcars$cyl)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
> abs(mean(mtcars$hp[mtcars$cyl==4])-mean(mtcars$hp[mtcars$cyl==8]))
abs(mean(split(mtcars, mtcars$cyl)$'4'$hp) - mean(split(mtcars, mtcars$cyl)$'8'$hp))
debu(ls)
debug(ls)
ls
debug(ls)
;s()
debug(ls)
ls()
setwd("C:/Users/Randy Proctor/Rprog/ProgrammingAssignment2")
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
View(SepalLength)
View(makeCacheMatrix)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
}
> x = rbind(c(1, -1/4), c(-1/4, 1))
> x <= rbind(c(1, -1/4), c(-1/4, 1))
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inv) i <<- inv
getinverse <- function() i
list(
set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse
)
}
cacheSolve <- function(x, ...) {
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
m <- x$get()
i <- solve(m, ...)
x$setinverse(i)
i
}
> m <- makeCacheMatrix(matrix(c(2, 0, 0, 2), c(2, 2)))
m <- makeCacheMatrix(matrix(c(2, 0, 0, 2), c(2, 2)))
cachesolve(m)
n
